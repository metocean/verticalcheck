// Generated by CoffeeScript 1.7.1
(function() {
  var checks, dns, httpget, parallel, parseurl, ping, run, series,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  dns = require('dns');

  ping = require('ping');

  parseurl = require('url').parse;

  httpget = require('http').get;

  series = function(tasks, callback) {
    var next, result;
    tasks = tasks.slice(0);
    next = function(cb) {
      var task;
      if (tasks.length === 0) {
        return cb();
      }
      task = tasks.shift();
      return task(function() {
        return next(cb);
      });
    };
    result = function(cb) {
      return next(cb);
    };
    if (callback != null) {
      result(callback);
    }
    return result;
  };

  parallel = function(tasks, callback) {
    var count, result;
    count = tasks.length;
    result = function(cb) {
      var task, _i, _len, _results;
      if (count === 0) {
        return cb();
      }
      _results = [];
      for (_i = 0, _len = tasks.length; _i < _len; _i++) {
        task = tasks[_i];
        _results.push(task(function() {
          count--;
          if (count === 0) {
            return cb();
          }
        }));
      }
      return _results;
    };
    if (callback != null) {
      result(callback);
    }
    return result;
  };

  checks = {
    dns: function(task, result, cb) {
      var host, ip, tasks, _fn, _ref;
      tasks = [];
      _ref = task.dns;
      _fn = function(host, ip) {
        return tasks.push(function(cb) {
          return dns.resolve4(host, function(err, addresses) {
            var a, skip, _i, _len;
            if (err != null) {
              result(task, 'dns', false, host, "" + host + " → ???");
              return cb();
            }
            if (addresses.length === 1 && addresses[0] === ip) {
              result(task, 'dns', true, host, "" + host + " → " + ip);
              return cb();
            }
            if (Object.prototype.toString.call(ip) === '[object Array]' && addresses.length === ip.length) {
              skip = false;
              for (_i = 0, _len = addresses.length; _i < _len; _i++) {
                a = addresses[_i];
                if (__indexOf.call(ip, a) < 0) {
                  skip = true;
                  break;
                }
              }
              if (!skip) {
                result('dns', true, host, "" + host + " → " + ip.length + " ip addresses");
                return cb();
              }
            }
            result(task, 'dns', false, host, "" + host + " → " + addresses + " instead of " + ip);
            return cb();
          });
        });
      };
      for (host in _ref) {
        ip = _ref[host];
        _fn(host, ip);
      }
      return parallel(tasks, cb);
    },
    ping: function(task, result, cb) {
      var tasks;
      tasks = task.ping.map(function(host) {
        return function(callback) {
          return ping.sys.probe(host, function(isAlive) {
            if (!isAlive) {
              result(task, 'ping', false, host, "" + host + " is down");
            } else {
              result(task, 'ping', true, host, "" + host + " is up");
            }
            return callback();
          });
        };
      });
      return parallel(tasks, cb);
    },
    http: function(task, result, cb) {
      var tasks;
      tasks = task.http.map(function(url) {
        return function(callback) {
          var chunks, code, href, key, options, port, req, value;
          code = 200;
          if (typeof url === 'object') {
            for (key in url) {
              value = url[key];
              href = key;
              code = value;
            }
            url = href;
          }
          chunks = parseurl(url);
          options = {
            hostname: chunks.hostname,
            port: chunks.port,
            path: chunks.path,
            agent: false
          };
          port = chunks.port;
          if (options.port == null) {
            if (chunks.protocol === 'https:') {
              options.port = 443;
            }
            if (chunks.protocol === 'http:') {
              options.port = 80;
            }
          }
          req = httpget(options, function(res) {
            if (res.statusCode === code) {
              result(task, 'http', true, url, "" + url + " responded");
            } else {
              result(task, 'http', false, url, "" + url + " expected " + code + " received " + res.statusCode + " instead");
            }
            return callback();
          }).on('error', function(err) {
            result(task, 'http', false, url, "" + url + " " + err.message);
            return callback();
          });
          return req.setTimeout(10000, function() {
            result(task, 'http', false, url, "" + url + " timed out after 5 seconds");
            return callback();
          });
        };
      });
      return parallel(tasks, cb);
    }
  };

  run = function(task, result, cb) {
    var check, f, tasks, _fn;
    if (Object.prototype.toString.call(task) === '[object Array]') {
      tasks = task.map(function(t) {
        return function(callback) {
          return run(t, result, callback);
        };
      });
      return parallel(tasks, cb);
    } else {
      tasks = [];
      _fn = function(check, f) {
        if (task[check] != null) {
          return tasks.push(function(cb) {
            return f(task, result, cb);
          });
        }
      };
      for (check in checks) {
        f = checks[check];
        _fn(check, f);
      }
      return series(tasks, cb);
    }
  };

  module.exports = run;

}).call(this);
