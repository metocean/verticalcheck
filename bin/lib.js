// Generated by CoffeeScript 1.7.1
(function() {
  var CSON, arg, args, checks, config, dns, fs, httpget, i, isInteractive, parallel, parseurl, ping, result, results, run, series, usage, waserror, _i, _len;

  require('colors');

  args = process.argv.slice(2);

  usage = "\n   Usage: " + 'verticalcheck'.cyan + " [config]\n   \n   Default configuration is " + 'verticalcheck.cson'.blue + "\n   \n   File format:\n   \n   [\n     {\n       dns:\n         'google.co.nz': '131.203.3.177'\n       ping: [\n         'google.co.nz'\n       ]\n       http: [\n         'https://google.co.nz/': 200\n       ]\n     }\n   ]\n";

  isInteractive = true;

  for (i = _i = 0, _len = args.length; _i < _len; i = ++_i) {
    arg = args[i];
    if (arg === '--json') {
      isInteractive = false;
      args.splice(i);
      break;
    }
  }

  if (args.length > 1) {
    console.error(usage);
    process.exit(1);
  }

  config = 'verticalcheck.cson';

  if (args.length === 1) {
    config = args[0];
  }

  fs = require('fs');

  if (!fs.existsSync(config)) {
    console.error("\nConfiguration not found at '" + config + "'\n");
    process.exit(1);
  }

  CSON = require('cson');

  config = CSON.parseFileSync(config);

  series = function(tasks, callback) {
    var next, result;
    tasks = tasks.slice(0);
    next = function(cb) {
      var task;
      if (tasks.length === 0) {
        return cb();
      }
      task = tasks.shift();
      return task(function() {
        return next(cb);
      });
    };
    result = function(cb) {
      return next(cb);
    };
    if (callback != null) {
      result(callback);
    }
    return result;
  };

  parallel = function(tasks, callback) {
    var count, result;
    count = tasks.length;
    result = function(cb) {
      var task, _j, _len1, _results;
      if (count === 0) {
        return cb();
      }
      _results = [];
      for (_j = 0, _len1 = tasks.length; _j < _len1; _j++) {
        task = tasks[_j];
        _results.push(task(function() {
          count--;
          if (count === 0) {
            return cb();
          }
        }));
      }
      return _results;
    };
    if (callback != null) {
      result(callback);
    }
    return result;
  };

  dns = require('dns');

  ping = require('ping');

  parseurl = require('url').parse;

  httpget = require('http').get;

  waserror = false;

  results = [];

  result = function(check, isUp, param, message) {
    if (!isInteractive) {
      return results.push({
        check: check,
        isUp: isUp,
        param: param,
        message: message
      });
    }
    if (isUp) {
      return console.log(" " + 'âˆš'.green + " " + message.green);
    }
    waserror = true;
    return console.error(" " + 'X'.red + " " + message.red);
  };

  checks = {
    dns: function(task, cb) {
      var host, ip, tasks, _fn, _ref;
      tasks = [];
      _ref = task.dns;
      _fn = function(host, ip) {
        return tasks.push(function(cb) {
          return dns.resolve4(host, function(err, addresses) {
            if (err != null) {
              result('dns', false, host, "unable to resolve dns for " + host);
              return cb();
            }
            if (addresses.length === 1 && addresses[0] === ip) {
              result('dns', true, host, "dns entry " + host + " resolves to " + ip);
              return cb();
            }
            result('dns', false, host, "dns entry " + host + " resolved to " + addresses + " instead of " + ip);
            return cb();
          });
        });
      };
      for (host in _ref) {
        ip = _ref[host];
        _fn(host, ip);
      }
      return parallel(tasks, cb);
    },
    ping: function(task, cb) {
      var tasks;
      tasks = task.ping.map(function(host) {
        return function(callback) {
          return ping.sys.probe(host, function(isAlive) {
            if (!isAlive) {
              result('ping', false, host, "ping " + host + " is down");
            } else {
              result('ping', true, host, "ping " + host + " is up");
            }
            return callback();
          });
        };
      });
      return parallel(tasks, cb);
    },
    http: function(task, cb) {
      var tasks;
      tasks = task.http.map(function(url) {
        return function(callback) {
          var chunks, code, href, key, options, port, value;
          code = 200;
          if (typeof url === 'object') {
            for (key in url) {
              value = url[key];
              href = key;
              code = value;
            }
            url = href;
            return callback();
          }
          chunks = parseurl(url);
          options = {
            hostname: chunks.hostname,
            port: chunks.port,
            path: chunks.path,
            agent: false
          };
          port = chunks.port;
          if (options.port == null) {
            if (chunks.protocol === 'https:') {
              options.port = 443;
            }
            if (chunks.protocol === 'http:') {
              options.port = 80;
            }
          }
          return httpget(options, function(res) {
            if (res.statusCode === code) {
              result('http', true, url, "http " + url + " is web'd");
            } else {
              result('http', false, url, "http expected " + code + "from " + url + " and received " + res.statusCode + " instead");
            }
            return callback();
          }).on('error', function(err) {
            result('http', false, url, "http tried to reach " + url + " and received " + err.message + " instead");
            return callback();
          });
        };
      });
      return parallel(tasks, cb);
    }
  };

  run = function(task, cb) {
    var check, f, tasks, _fn;
    if (Object.prototype.toString.call(task) === '[object Array]') {
      tasks = task.map(function(t) {
        return function(callback) {
          return run(t, callback);
        };
      });
      return parallel(tasks, cb);
    } else {
      tasks = [];
      _fn = function(check, f) {
        if (task[check] != null) {
          return tasks.push(function(cb) {
            return f(task, cb);
          });
        }
      };
      for (check in checks) {
        f = checks[check];
        _fn(check, f);
      }
      return series(tasks, cb);
    }
  };

  if (!isInteractive) {
    return run(config, function() {
      return console.log(results);
    });
  }

  console.log();

  console.log("   " + 'Vertical Check'.cyan + " -- Are you up or down?");

  console.log();

  run(config, function() {
    if (waserror) {
      console.error();
      console.error('   fin with errors.'.red);
      console.error();
      process.exit(1);
    }
    console.log();
    console.log('   fin.'.green);
    return console.log();
  });

}).call(this);
